/*============================================================================
  CMake - Cross Platform Makefile Generator
  Copyright 2004-2009 Kitware, Inc.
  Copyright 2004 Alexander Neundorf (neundorf@kde.org)

  Distributed under the OSI-approved BSD License (the "License");
  see accompanying file Copyright.txt for details.

  This software is distributed WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the License for more information.
============================================================================*/
#include "cmExtraKateGenerator.h"
#include "cmGlobalUnixMakefileGenerator3.h"
#include "cmLocalUnixMakefileGenerator3.h"
#include "cmMakefile.h"
#include "cmake.h"
#include "cmSourceFile.h"
#include "cmGeneratedFileStream.h"
#include "cmTarget.h"
#include "cmSystemTools.h"
#include "cmXMLSafe.h"

#include <cmsys/SystemTools.hxx>

//----------------------------------------------------------------------------
void cmExtraKateGenerator
::GetDocumentation(cmDocumentationEntry& entry, const char*) const
{
  entry.Name = this->GetName();
  entry.Brief = "Generates CodeBlocks project files.";
  entry.Full =
    "Project files for CodeBlocks will be created in the top directory "
    "and in every subdirectory which features a CMakeLists.txt file "
    "containing a PROJECT() call. "
    "Additionally a hierarchy of makefiles is generated into the "
    "build tree.  The appropriate make program can build the project through "
    "the default make target.  A \"make install\" target is also provided.";
}

cmExtraKateGenerator::cmExtraKateGenerator()
:cmExternalMakefileProjectGenerator()
{
#if defined(_WIN32)
  this->SupportedGlobalGenerators.push_back("MinGW Makefiles");
  this->SupportedGlobalGenerators.push_back("NMake Makefiles");
// disable until somebody actually tests it:
//  this->SupportedGlobalGenerators.push_back("MSYS Makefiles");
#endif
  this->SupportedGlobalGenerators.push_back("Ninja");
  this->SupportedGlobalGenerators.push_back("Unix Makefiles");
}


void cmExtraKateGenerator::Generate()
{
  const cmMakefile* mf
     = this->GlobalGenerator->GetLocalGenerators()[0]->GetMakefile();
  this->ProjectName = this->GenerateProjectName(mf->GetProjectName(),
                          mf->GetSafeDefinition("CMAKE_BUILD_TYPE"),
                          this->GetPathBasename(mf->GetHomeOutputDirectory()));
  this->CreateKateProjectFile(mf);
  this->CreateDummyKateProjectFile(mf);
}


void cmExtraKateGenerator::CreateKateProjectFile(const cmMakefile* mf) const
{
  std::string filename = mf->GetHomeOutputDirectory();
  filename += "/.kateproject";
  cmGeneratedFileStream fout(filename.c_str());
  if (!fout)
    {
    return;
    }

  std::string make = mf->GetRequiredDefinition("CMAKE_MAKE_PROGRAM");
  std::string args = mf->GetRequiredDefinition("CMAKE_KATE_MAKE_ARGUMENTS");

  fout <<
    "{\n"
    "\t\"name\": \"" << this->ProjectName << "\",\n"
    "\t\"directory\": \"" << mf->GetHomeDirectory() << "\",\n"
    "\t\"files\": [ { " << this->GenerateFilesString(mf) << "} ],\n"
    "\t\"build\": {\n"
    "\t\t\"directory\": \"" << mf->GetHomeOutputDirectory() << "\",\n"
    "\t\t\"build\": \"" << make << " " << args <<" all\",\n"
    "\t\t\"clean\": \"" << make << " clean\",\n"
    "\t\t\"quick\": \"" << make << " help\"\n"
    "\t}\n"
    "}\n";
}


void
cmExtraKateGenerator::CreateDummyKateProjectFile(const cmMakefile* mf) const
{
  std::string filename = mf->GetHomeOutputDirectory();
  filename += "/";
  filename += this->ProjectName;
  filename += ".kateproject";
  cmGeneratedFileStream fout(filename.c_str());
  if (!fout)
    {
    return;
    }

  fout << "#Generated by cmake, do not edit.\n";
}


std::string
cmExtraKateGenerator::GenerateFilesString(const cmMakefile* mf) const
{
  std::string s = mf->GetHomeDirectory();
  s += "/.git";
  if(cmSystemTools::FileExists(s.c_str()))
  {
    return std::string("\"git\": 1 ");
  }

  s = mf->GetHomeDirectory();
  s += "/.svn";
  if(cmSystemTools::FileExists(s.c_str()))
  {
    return std::string("\"svn\": 1 ");
  }

  
//   s =return std::string("\"filters\": [\"*.cpp\", \"*.c\", \"*.cxx\", \"*.C\", \"*.cc\", \"*.h\", \"*.hpp\", \"*.hh\", \"*.ui\", \"CMakeLists.txt\", \"Find*.cmake\"], \"recursive\": 1 ";
/*  s = std::string("\"filters\": [\"*.ui\", \"CMakeLists.txt\", \"Find*.cmake\"");
  const std::vector<std::string>& sourceExt = mf->GetSourceExtensions();
  for(std::vector<std::string>::const_iterator it = sourceExt.begin();
      it != sourceExt.end(); ++it)
    {
    s += ", \"*.";
    s += *it;
    s += "\"";
    }

  const std::vector<std::string>& headerExt = mf->GetHeaderExtensions();
  for(std::vector<std::string>::const_iterator it = headerExt.begin();
      it != headerExt.end(); ++it)
    {
    s += ", \"*.";
    s += *it;
    s += "\"";
    }
  s += "], \"recursive\": 1 ";

  return s;*/
    
  s = mf->GetHomeDirectory();
  s += "/";

  std::set<std::string> files;
  std::string tmp;
  const std::vector<cmLocalGenerator *>& lgs =
                                   this->GlobalGenerator->GetLocalGenerators();

  for (std::vector<cmLocalGenerator*>::const_iterator it=lgs.begin();
       it!=lgs.end(); it++)
    {
    cmMakefile* makefile=(*it)->GetMakefile();
    const std::vector<std::string>& listFiles=makefile->GetListFiles();
    for (std::vector<std::string>::const_iterator lt=listFiles.begin();
         lt!=listFiles.end(); lt++)
      {
      tmp=*lt;
    fprintf(stderr, "lf: %s\n", tmp.c_str());
//       cmSystemTools::ReplaceString(tmp, s.c_str(), "");
      // make sure the file is part of this source tree
//       if ((tmp[0]!='/') &&
//           (strstr(tmp.c_str(),
//                   cmake::GetCMakeFilesDirectoryPostSlash())==0))
        {
        files.insert(tmp);
//         tmp=cmSystemTools::GetFilenameName(tmp);
        }
      }

    const std::vector<cmSourceFile*>& sources = makefile->GetSourceFiles();
    for (std::vector<cmSourceFile*>::const_iterator sfIt = sources.begin();
         sfIt != sources.end(); sfIt++)
      {
      cmSourceFile* sf = *sfIt;
      if (sf->GetPropertyAsBool("GENERATED"))
        {
        continue;
        }

      tmp = sf->GetFullPath();
//       cmSystemTools::ReplaceString(tmp, s.c_str(), "");
      files.insert(tmp);
      }
    }

  const char* sep = "";
  tmp = "\"list\": [";
  for(std::set<std::string>::const_iterator it = files.begin();
      it != files.end(); ++it)
    {
    tmp += sep;
    tmp += " \"";
    tmp += *it;
    tmp += "\"";
    sep = ",";
    }
  tmp += "] ";

  return tmp;
}


std::string cmExtraKateGenerator::GenerateProjectName(const std::string& name,
                                                 const std::string& type,
                                                 const std::string& path) const
{
  return name + (type.empty() ? "" : "-") + type + "@" + path;
}


std::string cmExtraKateGenerator::GetPathBasename(const std::string& path)const
{
  std::string outputBasename = path;
  while (outputBasename.size() > 0 &&
         (outputBasename[outputBasename.size() - 1] == '/' ||
          outputBasename[outputBasename.size() - 1] == '\\'))
    {
    outputBasename.resize(outputBasename.size() - 1);
    }
  std::string::size_type loc = outputBasename.find_last_of("/\\");
  if (loc != std::string::npos)
    {
    outputBasename = outputBasename.substr(loc + 1);
    }

  return outputBasename;
}


// Create the command line for building the given target using the selected
// make
std::string cmExtraKateGenerator::BuildMakeCommand(const std::string& make,
                                const char* makefile, const char* target) const
{
  std::string command = make;
  if (strcmp(this->GlobalGenerator->GetName(), "NMake Makefiles")==0)
    {
    std::string makefileName = cmSystemTools::ConvertToOutputPath(makefile);
    command += " /NOLOGO /f &quot;";
    command += makefileName;
    command += "&quot; ";
    command += " VERBOSE=1 ";
    command += target;
    }
  else if (strcmp(this->GlobalGenerator->GetName(), "MinGW Makefiles")==0)
    {
    // no escaping of spaces in this case, see
    // http://public.kitware.com/Bug/view.php?id=10014
    std::string makefileName = makefile;
    command += " -f &quot;";
    command += makefileName;
    command += "&quot; ";
    command += " VERBOSE=1 ";
    command += target;
    }
  else if (strcmp(this->GlobalGenerator->GetName(), "Ninja")==0)
    {
    command += " -v ";
    command += target;
    }
  else
    {
    std::string makefileName = cmSystemTools::ConvertToOutputPath(makefile);
    command += " -f &quot;";
    command += makefileName;
    command += "&quot; ";
    command += " VERBOSE=1 ";
    command += target;
    }
  return command;
}
